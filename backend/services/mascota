import logging
from flask import abort
from backend.models import db  # ✅ Importa db correctamente desde `models`
from backend.models.mascota import Mascota

# ✅ Configurar logging para auditoría detallada
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("backend/logs/funkelin_services.log"),
        logging.StreamHandler()
    ]
)

def agregar_mascota(nombre: str, tipo: str, edad: int) -> Mascota:
    """Agrega una nueva mascota a la base de datos con validaciones defensivas y registro de eventos."""
    logging.debug(f"Inicio de `agregar_mascota()` con datos: nombre={nombre}, tipo={tipo}, edad={edad}")  # DEBUG

    try:
        if not isinstance(nombre, str) or len(nombre.strip()) < 2 or len(nombre.strip()) > 50:
            logging.warning(f"⚠ Nombre inválido en `agregar_mascota()`: {nombre}")  # WARNING
            raise ValueError("El nombre debe tener entre 2 y 50 caracteres.")
        if not isinstance(tipo, str) or tipo.strip() not in ["Perro", "Gato", "Ave", "Otro"]:
            logging.warning(f"⚠ Tipo inválido en `agregar_mascota()`: {tipo}")  # WARNING
            raise ValueError("Tipo de mascota no válido.")
        if not isinstance(edad, int) or edad <= 0:
            logging.warning(f"⚠ Edad inválida en `agregar_mascota()`: {edad}")  # WARNING
            raise ValueError("La edad debe ser un número entero positivo.")

        nueva_mascota = Mascota(nombre=nombre.strip(), tipo=tipo.strip(), edad=edad)

        try:
            with db.session.begin():
                db.session.add(nueva_mascota)
                db.session.commit()
            logging.info(f"✅ Mascota agregada exitosamente: {nueva_mascota.to_dict()}")  # INFO
        except Exception as e:
            db.session.rollback()
            logging.error(f"⚠ Error crítico en `agregar_mascota()`: {str(e)}")  # ERROR
            raise RuntimeError(f"Error interno al guardar la mascota: {str(e)}")

        return nueva_mascota

    except Exception as e:
        logging.error(f"⚠ Error general en `agregar_mascota()`: {str(e)}")  # ERROR
        raise RuntimeError(f"Error inesperado: {str(e)}")

def obtener_mascotas() -> list[dict]:
    """Devuelve la lista de mascotas con validaciones de integridad y auditoría."""
    logging.debug("Ejecutando `obtener_mascotas()`")  # DEBUG

    try:
        with db.session.no_autoflush:
            mascotas = Mascota.query.all()
            assert isinstance(mascotas, list), "⚠ La consulta de mascotas no devolvió una lista."

            logging.info(f"✅ Mascotas obtenidas exitosamente ({len(mascotas)} registros)")  # INFO
            return [mascota.to_dict() for mascota in mascotas]

    except Exception as e:
        db.session.rollback()
        logging.error(f"⚠ Error crítico en `obtener_mascotas()`: {str(e)}")  # ERROR
        raise RuntimeError(f"Error interno al obtener la lista de mascotas: {str(e)}")

def eliminar_mascota(id: int) -> bool:
    """Elimina una mascota de la base de datos con validaciones robustas y auditoría."""
    logging.debug(f"Ejecutando `eliminar_mascota()` con ID={id}")  # DEBUG

    try:
        if not isinstance(id, int) or id <= 0:
            logging.warning(f"⚠ ID inválido en `eliminar_mascota()`: {id}")  # WARNING
            raise ValueError("El ID debe ser un número entero positivo.")

        mascota = Mascota.query.get(id)
        if mascota is None:
            logging.warning(f"⚠ Intento de eliminar mascota no existente (ID={id})")  # WARNING
            abort(404, f"No se encontró ninguna mascota con ID: {id}")

        try:
            with db.session.begin():
                db.session.delete(mascota)
                db.session.commit()
            logging.info(f"✅ Mascota eliminada exitosamente: ID {id}")  # INFO
        except Exception as e:
            db.session.rollback()
            logging.error(f"⚠ Error crítico en `eliminar_mascota()`: {str(e)}")  # ERROR
            raise RuntimeError(f"Error interno al eliminar la mascota con ID {id}: {str(e)}")

        return True

    except Exception as e:
        logging.error(f"⚠ Error general en `eliminar_mascota()`: {str(e)}")  # ERROR
        raise RuntimeError(f"Error inesperado: {str(e)}")